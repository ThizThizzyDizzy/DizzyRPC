using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using DizzyRPC.Attribute;
using DizzyRPC.Debugger;
using UnityEditor;
using UnityEngine;
using VRC.SDK3.UdonNetworkCalling;
using VRC.SDKBase;
using VRC.Udon;
using VRC.Udon.Common.Interfaces;
using VRC.Udon.Editor.ProgramSources.UdonGraphProgram;
using VRRefAssist;
using Assembly = System.Reflection.Assembly;

namespace DizzyRPC.Editor
{
    public static class RPCCompiler
    {
        private static readonly List<GeneratedSingleton> generatedSingletons = new();
        private static readonly List<GeneratedRouter> generatedRouters = new();
        private static readonly List<GeneratedRPC> generatedRPCs = new();
        private static readonly List<string> routableRPCContainers = new();

        private static bool hasCompiled = false;

        public static GeneratedSingleton[] Singletons
        {
            get
            {
                if (!hasCompiled) CompileRPCs();
                return generatedSingletons.ToArray();
            }
        }

        public static GeneratedRouter[] Routers
        {
            get
            {
                if (!hasCompiled) CompileRPCs();
                return generatedRouters.ToArray();
            }
        }

        public static GeneratedRPC[] RPCs
        {
            get
            {
                if (!hasCompiled) CompileRPCs();
                return generatedRPCs.ToArray();
            }
        }

        public static string[] RoutableRPCContainers
        {
            get
            {
                if (!hasCompiled) CompileRPCs();
                return routableRPCContainers.ToArray();
            }
        }

        private static bool needsRegen = false;

        [InitializeOnLoadMethod]
        private static void OnLoad()
        {
            EditorApplication.update += OnUpdate;
            EditorApplication.playModeStateChanged += OnPlayModeStateChanged;

            if (RPCCompilerSettings.AutoRecompileInEditor && !EditorApplication.isPlayingOrWillChangePlaymode) needsRegen = true;
        }

        public static void OnGraphRPCSettingsChanged()
        {
            if (RPCCompilerSettings.AutoRecompileInEditor && !EditorApplication.isPlayingOrWillChangePlaymode) needsRegen = true;
        }

        private static void OnUpdate()
        {
            if (RPCCompilerSettings.AutoRecompileForPlayMode && EditorPrefs.GetBool("DizzyRPC_ContinueEnteringPlayMode"))
            {
                EditorPrefs.DeleteKey("DizzyRPC_ContinueEnteringPlayMode");
                EditorApplication.EnterPlaymode();
                return;
            }

            if (needsRegen)
            {
                Debug.Log("[DizzyRPC] Automatically recompiling DizzyRPC!");
                needsRegen = false;
                Compile(GenerationMode.Editor);
            }
        }

        [RunOnBuild]
        private static void OnBuild()
        {
            if (RPCCompilerSettings.AutoRecompileOnBuild)
            {
                Compile(GenerationMode.Build);
            }
        }

        private static void OnPlayModeStateChanged(PlayModeStateChange state)
        {
            if (!RPCCompilerSettings.AutoRecompileForPlayMode) return;
            switch (state)
            {
                case PlayModeStateChange.ExitingEditMode:
                    if (Compile(GenerationMode.Build)) EditorPrefs.SetBool("DizzyRPC_ContinueEnteringPlayMode", true);
                    break;
                case PlayModeStateChange.EnteredEditMode:
                    Compile(GenerationMode.Editor);
                    break;
            }
        }

        [MenuItem("Tools/DizzyRPC/Compile RPCs/Compile for Editor")]
        private static bool CompileEditor() => Compile(GenerationMode.Editor);

        [MenuItem("Tools/DizzyRPC/Compile RPCs/Compile for Build")]
        private static bool CompileBuild()
        {
            if (RPCCompilerSettings.AutoRecompileInEditor)
            {
                EditorUtility.DisplayDialog("DizzyRPC", "DizzyRPC is configured to automatically compile for editor when any changes are made.\nYou must disable that setting in order to manually compile for build.", "OK");
                return false;
            }

            return Compile(GenerationMode.Build);
        }

        [MenuItem("Tools/DizzyRPC/Compile RPCs/Remove all generated Code")]
        private static bool Clean()
        {
            if (!EditorUtility.DisplayDialog("DizzyRPC", $"Remove ALL code generated by DizzyRPC?\nThis will cause compilation errors if you are using any RPCs!{(RPCCompilerSettings.AutoRecompileInEditor || RPCCompilerSettings.AutoRecompileForPlayMode || RPCCompilerSettings.AutoRecompileOnBuild ? "\nThis will also disable ALL automatic RPC compilation settings." : "")}", "Yes", "No")) return false;
            RPCCompilerSettings.AutoRecompileInEditor = false;
            RPCCompilerSettings.AutoRecompileForPlayMode = false;
            RPCCompilerSettings.AutoRecompileOnBuild = false;
            return Compile(GenerationMode.Clean);
        }

        private static bool Compile(GenerationMode mode)
        {
            if (mode == GenerationMode.Clean)
            {
                generatedSingletons.Clear();
                generatedRouters.Clear();
                generatedRPCs.Clear();
                routableRPCContainers.Clear();
            }
            else
            {
                CompileRPCs();
            }

            bool anyChanges = false;

            try
            {
                AssetDatabase.StartAssetEditing();

                anyChanges |= GenerateRPCs(typeof(RPCChannel), FindMonoAssetPath(typeof(RPCChannel)), GenerationTarget.Channel, mode);

                foreach (var type in Assembly.GetAssembly(typeof(RPCMethodAttribute)).GetTypes().Where((type) => type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance).Any((method) => method.GetCustomAttribute<RPCMethodAttribute>() != null)))
                {
                    anyChanges |= GenerateRPCs(type, FindMonoAssetPath(type), GenerationTarget.MethodContainer, mode);
                }

                foreach (var graph in RPCGraphEditor.graphDataStorage.graphData)
                {
                    var program = AssetDatabase.LoadAssetAtPath<UdonGraphProgramAsset>(AssetDatabase.GUIDToAssetPath(graph.guid));
                    if (program == null)
                    {
                        Debug.LogWarning($"[DizzyRPC] Skipping graph {graph.guid} because no matching Udon Graph Program Asset was found.");
                        continue;
                    }

                    anyChanges |= GenerateRPCs(graph, program, mode);
                }
            }
            finally
            {
                AssetDatabase.StopAssetEditing();
                AssetDatabase.Refresh();
            }

            return anyChanges;
        }


        private static string FindMonoAssetPath(Type type)
        {
            foreach (string guid in AssetDatabase.FindAssets($"{type.Name} t:MonoScript"))
            {
                string assetPath = AssetDatabase.GUIDToAssetPath(guid);
                MonoScript monoScript = AssetDatabase.LoadAssetAtPath<MonoScript>(assetPath);
                if (monoScript != null && monoScript.GetClass() == type)
                {
                    return assetPath;
                }
            }

            throw new Exception($"Could not find MonoScript asset for type {type.FullName}!");
        }

        private static void CompileRPCs()
        {
            hasCompiled = true;

            generatedSingletons.Clear();
            generatedRouters.Clear();
            generatedRPCs.Clear();
            routableRPCContainers.Clear();

            // Generate the RPC code
            var assembly = Assembly.GetAssembly(typeof(RPCMethodAttribute));
            List<Type> singletonTypes = new();
            List<Type> types = new(assembly.GetTypes().Where((t) => t.IsClass && !t.IsAbstract));

            var graphDataObject = AssetDatabase.LoadAssetAtPath<RPCGraphDataStorage>("Assets/DizzyRPC/RPCGraphData.asset");

            // Routable RPC Containers (These must be first to ensure they are set even if compilation fails)
            foreach (var type in types)
            {
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
                {
                    var rpcMethod = method.GetCustomAttribute<RPCMethodAttribute>();
                    if (rpcMethod == null) continue;

                    bool isSingleton = false;
                    // Check for VRRefAssist Singleton attribute
                    foreach (var att in type.GetCustomAttributes())
                    {
                        var typ = att.GetType();
                        if (typ.FullName == "VRRefAssist.Singleton")
                        {
                            isSingleton = true;
                            break;
                        }
                    }

                    if (isSingleton) continue;

                    routableRPCContainers.Add(type.FullName);
                }
            }

            // Udon Graph Routable RPC Containers
            foreach (var graph in RPCGraphEditor.graphDataStorage.graphData)
            {
                if (graph.rpcMethods.Count > 0 && !graph.singleton)
                {
                    var program = AssetDatabase.LoadAssetAtPath<UdonGraphProgramAsset>(AssetDatabase.GUIDToAssetPath(graph.guid));
                    routableRPCContainers.Add(program.name);
                }
            }

            // Routers
            foreach (var type in types)
            {
                if (IsDerivedFromGeneric(type, typeof(RPCRouter<,>), out var actualBase))
                {
                    var genericArgs = actualBase.GetGenericArguments();
                    generatedRouters.Add(new GeneratedRouter()
                    {
                        id = generatedRouters.Count,
                        routerType = type,
                        routableType = genericArgs[0],
                        idType = genericArgs[1]
                    });
                }

                // U# routers routing Udon Graph RPCs
                if (IsDerivedFromGeneric(type, typeof(RPCRouter<>), out var actualBaseGraph))
                {
                    var attr = type.GetCustomAttribute<RPCGraphRouterAttribute>();
                    if (attr == null) throw new Exception($"[DizzyRPC] RPC Router {type.FullName} Must have an [RPCGraphRouter] attribute!");
                    var genericArgs = actualBaseGraph.GetGenericArguments();
                    generatedRouters.Add(new GeneratedRouter()
                    {
                        id = generatedRouters.Count,
                        routerType = type,
                        routableType = typeof(UdonBehaviour),
                        routableGraphName = attr.name,
                        idType = genericArgs[0]
                    });
                }
            }

            // Udon Graph Routers
            foreach (var graph in graphDataObject.graphData)
            {
                if (!graph.router) continue;

                var path = AssetDatabase.GUIDToAssetPath(graph.guid);
                if (path == "") continue;

                UdonGraphProgramAsset program = AssetDatabase.LoadAssetAtPath<UdonGraphProgramAsset>(path);

                Type routableType = typeof(UdonBehaviour);
                foreach (var type in types)
                {
                    if (type.FullName == graph.routerTypeName) routableType = type;
                }

                generatedRouters.Add(new GeneratedRouter()
                {
                    id = generatedRouters.Count,
                    routerType = typeof(UdonBehaviour),
                    routableType = routableType,
                    routableGraphName = graph.routerTypeName,
                    idType = graph.RouterIdType
                });
            }

            // Singletons & RPCs
            foreach (var type in types)
            {
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
                {
                    var rpcMethod = method.GetCustomAttribute<RPCMethodAttribute>();
                    if (rpcMethod == null) continue;

                    if (method.GetCustomAttribute<NetworkCallableAttribute>() != null) throw new Exception($"[DizzyRPC] RPCMethod {type.FullName}.{method.Name} must not have the NetworkCallable attribute!");
                    if (!method.IsPublic) throw new Exception($"[DizzyRPC] RPCMethod {type.FullName}.{method.Name} must be public!");
                    if (!method.Name.StartsWith("_")) throw new Exception($"[DizzyRPC] The name of RPCMethod {type.FullName}.{method.Name} must begin with _!");

                    List<GeneratedRPCParameter> parameters = new();
                    foreach (var param in method.GetParameters()) parameters.Add(new(param));

                    var mode = rpcMethod.CalculateMode();

                    bool generated = false;

                    // Check for VRRefAssist Singleton attribute
                    foreach (var att in type.GetCustomAttributes())
                    {
                        var typ = att.GetType();
                        if (typ.FullName == "VRRefAssist.Singleton")
                        {
                            if (!singletonTypes.Contains(type))
                            {
                                generatedSingletons.Add(new GeneratedSingleton()
                                {
                                    id = generatedSingletons.Count,
                                    type = type
                                });
                                singletonTypes.Add(type);
                            }

                            generatedRPCs.Add(new GeneratedRPC()
                            {
                                id = (ushort)generatedRPCs.Count,
                                isUniqueType = types.Count((t) => t.Name == type.Name) == 1,
                                methodName = method.Name,
                                methodParameters = parameters,
                                singleton = generatedSingletons[singletonTypes.IndexOf(type)],
                                type = type,
                                mode = mode,
                                ignoreDuplicates = rpcMethod.IgnoreDuplicates
                            });
                            generated = true;
                            break;
                        }
                    }

                    if (generated) continue;

                    // Check for RPC router
                    foreach (var router in generatedRouters)
                    {
                        if (router.routableType == type)
                        {
                            var rpc = new GeneratedRPC()
                            {
                                id = (ushort)generatedRPCs.Count,
                                isUniqueType = types.Count((t) => t.Name == type.Name) == 1,
                                methodName = method.Name,
                                methodParameters = parameters,
                                router = router,
                                type = type,
                                mode = mode,
                                ignoreDuplicates = rpcMethod.IgnoreDuplicates
                            };
                            generatedRPCs.Add(rpc);
                            generated = true;
                            break;
                        }
                    }

                    if (generated) continue;

                    throw new Exception($"Could not map RPCs to {method.Name} in {type.Name}!");
                }
            }

            // Udon Graph Singletons & RPCs
            foreach (var graph in graphDataObject.graphData)
            {
                var path = AssetDatabase.GUIDToAssetPath(graph.guid);
                if (path == "") continue;

                GeneratedSingleton singleton = null;
                if (graph.singleton)
                {
                    generatedSingletons.Add(singleton = new GeneratedSingleton()
                    {
                        id = generatedSingletons.Count,
                        type = typeof(UdonBehaviour),
                        udonGraphGuid = graph.guid
                    });
                }

                UdonGraphProgramAsset program = AssetDatabase.LoadAssetAtPath<UdonGraphProgramAsset>(path);

                foreach (var method in graph.rpcMethods)
                {
                    if (!method.name.StartsWith("_")) throw new Exception($"[DizzyRPC] The name of RPCMethod {program.name}.{method.name} must begin with _!");
                    List<GeneratedRPCParameter> parameters = new();
                    foreach (var node in program.graphData.EventNodes)
                    {
                        if (node.GetCustomEventName() == method.name)
                        {
                            for (int i = 0; i < int.Parse(node.fullName.Substring(13, 1)); i++)
                            {
                                parameters.Add(new()
                                {
                                    type = Type.GetType(node.nodeValues[i + 2].stringValue.Split("|", 2)[1]),
                                    name = $"param{i + 1}"
                                });
                            }
                        }
                    }

                    var mode = method.CalculateMode();

                    bool generated = false;

                    if (graph.singleton)
                    {
                        generatedRPCs.Add(new GeneratedRPC()
                        {
                            id = (ushort)generatedRPCs.Count,
                            methodName = method.name,
                            methodParameters = parameters,
                            singleton = singleton,
                            type = typeof(UdonBehaviour),
                            graphName = program.name,
                            mode = mode,
                            ignoreDuplicates = method.ignoreDuplicates
                        });
                        generated = true;
                    }

                    if (generated) continue;

                    // Check for RPC router
                    foreach (var router in generatedRouters)
                    {
                        if (router.routableType == typeof(UdonBehaviour) && router.routableGraphName == program.name)
                        {
                            var rpc = new GeneratedRPC()
                            {
                                id = (ushort)generatedRPCs.Count,
                                methodName = method.name,
                                methodParameters = parameters,
                                router = router,
                                type = typeof(UdonBehaviour),
                                graphName = program.name,
                                mode = mode,
                                ignoreDuplicates = method.IgnoreDuplicates
                            };
                            generatedRPCs.Add(rpc);
                            generated = true;
                            break;
                        }
                    }

                    if (generated) continue;

                    throw new Exception($"Could not map RPCs to {method.name} in {program.name}!");
                }
            }

            // RPC Hooks
            foreach (var type in types)
            {
                foreach (var method in type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance))
                {
                    var hook = method.GetCustomAttribute<RPCHookAttribute>();
                    if (hook == null) continue;

                    if (method.ReturnType != typeof(bool)) throw new Exception($"RPCHook {type}.{method.Name} return type must be bool!");

                    bool found = false;
                    foreach (var rpc in generatedRPCs)
                    {
                        if (hook.FullTypeName == rpc.FullTypeName && hook.methodName == rpc.methodName)
                        {
                            found = true;

                            List<GeneratedRPCParameter> hookParameters = new List<GeneratedRPCParameter>();

                            foreach (var parameter in method.GetParameters())
                            {
                                hookParameters.Add(new GeneratedRPCParameter()
                                {
                                    type = parameter.ParameterType,
                                    name = parameter.Name
                                });
                                if (!rpc.methodParameters.Any(param => param.name == parameter.Name && param.type == parameter.ParameterType))
                                {
                                    throw new Exception($"Cannot compile RPC hook {type.FullName}.{method.Name} for {hook.FullTypeName}.{hook.methodName}! Parameter {parameter.Name} of type {parameter.ParameterType.FullName} is not present on the target RPC method! RPC hooks must only use parameters that exist on the RPC method.");
                                }
                            }

                            GeneratedSingleton hookSingleton = null;
                            foreach (var singleton in generatedSingletons)
                            {
                                if (singleton.type == type)
                                {
                                    hookSingleton = singleton;
                                    break;
                                }
                            }

                            if (hookSingleton == null)
                            {
                                generatedSingletons.Add(hookSingleton = new GeneratedSingleton()
                                {
                                    id = generatedSingletons.Count,
                                    type = type
                                });
                            }

                            rpc.hooks.Add(new GeneratedRPCHook() { singleton = hookSingleton, methodName = method.Name, methodParameters = hookParameters });
                            break;
                        }
                    }

                    if (!found) throw new Exception($"[DizzyRPC] Could not generate RPC hook: {hook.type.FullName}.{hook.methodName}! (No matching RPC was found)");
                }
            }

            // Udon Graph RPC Hooks
            foreach (var graph in graphDataObject.graphData)
            {
                var path = AssetDatabase.GUIDToAssetPath(graph.guid);
                if (path == "") continue;

                GeneratedSingleton hookSingleton = null;
                foreach (var singleton in generatedSingletons)
                {
                    if (singleton.type == typeof(UdonBehaviour))
                    {
                        hookSingleton = singleton;
                        break;
                    }
                }

                UdonGraphProgramAsset program = AssetDatabase.LoadAssetAtPath<UdonGraphProgramAsset>(path);

                foreach (var hook in graph.rpcHooks)
                {
                    bool found = false;
                    foreach (var rpc in generatedRPCs)
                    {
                        if (hook.fullTypeName == rpc.FullTypeName && hook.methodName == rpc.methodName)
                        {
                            List<GeneratedRPCParameter> hookParameters = new List<GeneratedRPCParameter>();
                            found = true;
                            foreach (var node in program.graphData.EventNodes)
                            {
                                if (node.GetCustomEventName() == hook.name)
                                {
                                    for (int i = 0; i < int.Parse(node.fullName.Substring(13, 1)); i++)
                                    {
                                        var parameter = new GeneratedRPCParameter()
                                        {
                                            name = hook.parameterNames[i],
                                            type = Type.GetType(node.nodeValues[i + 2].stringValue.Split("|", 2)[1])
                                        };
                                        hookParameters.Add(parameter);
                                        if (!rpc.methodParameters.Any(param => param.name == parameter.name && param.type == parameter.type))
                                        {
                                            throw new Exception($"Cannot compile RPC hook {program.name}.{hook.name} for {hook.fullTypeName}.{hook.methodName}! Parameter {parameter.name} of type {parameter.type} is not present on the target RPC method! RPC hooks must only use parameters that exist on the RPC method.");
                                        }
                                    }
                                }
                            }

                            if (hookSingleton == null) throw new Exception($"Cannot compile RPC hook {hook.methodName}! Udon Graph program {program.name} is not a singleton!");

                            rpc.hooks.Add(new GeneratedRPCHook() { singleton = hookSingleton, methodName = hook.name, methodParameters = hookParameters });
                        }
                    }

                    if (!found) throw new Exception($"[DizzyRPC] Could not generate RPC hook {program.name}.{hook.name} for {hook.fullTypeName}.{hook.methodName}! (No matching RPC was found)");
                }
            }
        }

        private static bool IsDerivedFromGeneric(Type type, Type genericBase, out Type actualBase)
        {
            while ((type = type.BaseType) != null)
            {
                if (type.IsGenericType && type.GetGenericTypeDefinition() == genericBase)
                {
                    actualBase = type;
                    return true;
                }
            }

            actualBase = default;
            return false;
        }

        private static bool GenerateRPCs(Type type, string path, GenerationTarget target, GenerationMode mode)
        {
            List<string> generatedLines = new();

            if (mode != GenerationMode.Clean)
            {
                switch (target)
                {
                    case GenerationTarget.Channel:
                        foreach (GeneratedRPC rpc in generatedRPCs)
                        {
                            generatedLines.Add($"public const int RPC_{rpc.TypeName}_{rpc.methodName} = {rpc.id};");
                        }

                        generatedLines.Add("");
                        if (mode != GenerationMode.Build) break;

                        foreach (GeneratedSingleton singleton in generatedSingletons)
                        {
                            generatedLines.Add($"[{typeof(SerializeField).FullName}] private {singleton.type.FullName} singleton_{singleton.id};");
                        }

                        generatedLines.Add("");
                        foreach (GeneratedRouter router in generatedRouters)
                        {
                            generatedLines.Add($"[{typeof(SerializeField).FullName}] private {router.routerType.FullName} router_{router.id};");
                        }

                        generatedLines.Add("");

                        foreach (GeneratedRPC rpc in generatedRPCs)
                        {
                            if (rpc.mode != RPCSyncMode.Event) continue;
                            List<string> methodParameters = new();
                            List<string> callParameters = new();

                            if (rpc.router != null) methodParameters.Add($"{rpc.router.idType.FullName} _id");

                            foreach (var parameter in rpc.methodParameters)
                            {
                                methodParameters.Add($"{parameter.type.FullName} {parameter.name}");
                                callParameters.Add($"{parameter.name}");
                            }

                            generatedLines.Add($"[{typeof(NetworkCallableAttribute).Namespace}.NetworkCallable]");
                            generatedLines.Add($"public void RPC_{rpc.id}({string.Join(", ", methodParameters)}) {{");
                            generatedLines.Add($"    debugger.{nameof(RPCDebugger._OnReceiveRPC)}({typeof(NetworkCalling).FullName}.{nameof(NetworkCalling.CallingPlayer)}, {rpc.id}{(rpc.router != null ? ", _id" : "")}{(callParameters.Count > 0 ? ", " : "")}{string.Join(", ", callParameters)});");
                            foreach (var hook in rpc.hooks)
                            {
                                List<string> hookCallParameters = new();

                                foreach (var parameter in hook.methodParameters)
                                {
                                    hookCallParameters.Add($"{parameter.name}");
                                }

                                if (hook.singleton.type == typeof(UdonBehaviour))
                                {
                                    hookCallParameters.Insert(0, $"{typeof(NetworkEventTarget)}.{nameof(NetworkEventTarget.Self)}");
                                    hookCallParameters.Insert(1, $"\"{hook.methodName}\"");

                                    generatedLines.Add($"}}");
                                    generatedLines.Add($"public void _RPC_{rpc.id}_PostHook_{hook.singleton.id}({string.Join(", ", methodParameters)}) {{");
                                }
                                else
                                {
                                    generatedLines.Add($"    if (!singleton_{hook.singleton.id}.{hook.methodName}({string.Join(", ", hookCallParameters)})) return;");
                                }
                            }

                            if (rpc.singleton != null)
                            {
                                if (rpc.type == typeof(UdonBehaviour))
                                {
                                    callParameters.Insert(0, $"{typeof(NetworkEventTarget)}.{nameof(NetworkEventTarget.Self)}");
                                    callParameters.Insert(1, $"\"{rpc.methodName}\"");
                                    generatedLines.Add($"    singleton_{rpc.singleton.id}.SendCustomNetworkEvent({string.Join(", ", callParameters)});");
                                }
                                else
                                {
                                    generatedLines.Add($"    singleton_{rpc.singleton.id}.{rpc.methodName}({string.Join(", ", callParameters)});");
                                }
                            }

                            if (rpc.router != null)
                            {
                                if (rpc.router.routerType == typeof(UdonBehaviour))
                                {
                                    generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_Target\", \"_Route_{rpc.id}\");");
                                    generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_id\", _id);");
                                    for (int i = 0; i < callParameters.Count; i++)
                                    {
                                        generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_Param{i+1}\", {callParameters[i]});");
                                    }
                                    generatedLines.Add($"    router_{rpc.router.id}.SendCustomEvent(\"_RPC_RouteRPC\");");
                                }
                                else
                                {
                                    generatedLines.Add($"    router_{rpc.router.id}._Route(_id).{rpc.methodName}({string.Join(", ", callParameters)});");
                                }
                            }

                            generatedLines.Add($"}}");
                        }

                        generatedLines.Add("");
                        generatedLines.Add("private void _DecodeRPC(int id, byte[] data) {");
                        generatedLines.Add("    switch(id){");
                        foreach (GeneratedRPC rpc in generatedRPCs)
                        {
                            if (rpc.mode != RPCSyncMode.Variable) continue;
                            generatedLines.Add($"        case {rpc.id}: _DecodeRPC_{rpc.id}(data); break;");
                        }

                        generatedLines.Add("    }");
                        generatedLines.Add("}");

                        generatedLines.Add("");
                        foreach (GeneratedRPC rpc in generatedRPCs)
                        {
                            if (rpc.mode != RPCSyncMode.Variable) continue;
                            List<(Type, string)> rpcParameters = new();
                            List<string> callParameters = new();
                            List<string> methodParameters = new();

                            if (rpc.router != null) rpcParameters.Add((rpc.router.idType, "_id"));

                            foreach (var parameter in rpc.methodParameters)
                            {
                                rpcParameters.Add((parameter.type, parameter.name));
                                callParameters.Add($"{parameter.name}");
                            }

                            generatedLines.Add($"private void _DecodeRPC_{rpc.id}(byte[] data) {{");
                            generatedLines.Add($"    int _data_position = 0;");

                            foreach (var (parameterType, parameterName) in rpcParameters)
                            {
                                methodParameters.Add($"{parameterType.FullName} {parameterName}");
                                generatedLines.Add($"    {parameterType.FullName} {parameterName} = Decode{parameterType.Name.Replace("[]", "Array")}(data, ref _data_position);");
                            }

                            foreach (var hook in rpc.hooks)
                            {
                                List<string> hookCallParameters = new();

                                foreach (var parameter in hook.methodParameters)
                                {
                                    hookCallParameters.Add($"{parameter.name}");
                                }

                                if (hook.singleton.type == typeof(UdonBehaviour))
                                {
                                    hookCallParameters.Insert(0, $"{typeof(NetworkEventTarget)}.{nameof(NetworkEventTarget.Self)}");
                                    hookCallParameters.Insert(1, $"\"{hook.methodName}\"");
                                    generatedLines.Add($"    singleton_{hook.singleton.id}.SendCustomNetworkEvent({string.Join(", ", hookCallParameters)});");

                                    generatedLines.Add($"}}");
                                    generatedLines.Add($"public void _RPC_{rpc.id}_PostHook_{hook.singleton.id}({string.Join(", ", methodParameters)}) {{");
                                }
                                else
                                {
                                    generatedLines.Add($"    if (!singleton_{hook.singleton.id}.{hook.methodName}({string.Join(", ", hookCallParameters)})) return;");
                                }
                            }

                            if (rpc.singleton != null)
                            {
                                if (rpc.type == typeof(UdonBehaviour))
                                {
                                    callParameters.Insert(0, $"{typeof(NetworkEventTarget).FullName}.{nameof(NetworkEventTarget.Self)}");
                                    callParameters.Insert(1, $"\"{rpc.methodName}\"");
                                    generatedLines.Add($"    singleton_{rpc.singleton.id}.SendCustomNetworkEvent({string.Join(", ", callParameters)});");
                                }
                                else
                                {
                                    generatedLines.Add($"    singleton_{rpc.singleton.id}.{rpc.methodName}({string.Join(", ", callParameters)});");
                                }
                            }

                            if (rpc.router != null)
                            {
                                if (rpc.router.routerType == typeof(UdonBehaviour))
                                {
                                    generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_Target\", \"_Route_{rpc.id}\");");
                                    generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_id\", _id);");
                                    for (int i = 0; i < callParameters.Count; i++)
                                    {
                                        generatedLines.Add($"    router_{rpc.router.id}.SetProgramVariable(\"_RPC_ROUTER_Param{i}\", {callParameters[i]});");
                                    }
                                    generatedLines.Add($"    router_{rpc.router.id}.SendCustomEvent(\"_RPC_RouteRPC\");");
                                }
                                else
                                {
                                    generatedLines.Add($"    router_{rpc.router.id}._Route(_id).{rpc.methodName}({string.Join(", ", callParameters)});");
                                }
                            }

                            generatedLines.Add($"}}");
                        }

                        break;
                    case GenerationTarget.MethodContainer:
                        generatedLines.Add($"[{typeof(SerializeField).FullName}] private {typeof(RPCManager).FullName} _rpc_manager;");
                        if (mode == GenerationMode.Build)
                        {
                            foreach (GeneratedRouter router in generatedRouters)
                            {
                                if (router.routableType == type) generatedLines.Add($"[{typeof(SerializeField).FullName}] private {router.routerType.FullName} _rpc_router{router.id};");
                            }
                        }

                        generatedLines.Add("");

                        foreach (GeneratedRPC rpc in generatedRPCs)
                        {
                            var modeName = rpc.mode switch
                            {
                                RPCSyncMode.Event => "Event",
                                RPCSyncMode.Variable => "Variable",
                                _ => ""
                            };

                            if (rpc.router != null && rpc.router.routableType != type) continue;
                            if (rpc.singleton != null && rpc.singleton.type != type) continue;

                            List<string> methodParameters = new();
                            List<string> localCallParameters = new();
                            List<string> remoteCallParameters = new();

                            methodParameters.Add($"{typeof(VRCPlayerApi).FullName} target");
                            remoteCallParameters.Add("target");
                            remoteCallParameters.Add($"{typeof(RPCChannel).FullName}.RPC_{rpc.TypeName}_{rpc.methodName}");
                            if (rpc.mode == RPCSyncMode.Variable) remoteCallParameters.Add(rpc.ignoreDuplicates ? "true" : "false");

                            if (rpc.router != null) remoteCallParameters.Add($"_rpc_router{rpc.router.id}._GetId(this)");

                            foreach (var parameter in rpc.methodParameters)
                            {
                                methodParameters.Add($"{parameter.type.FullName} {parameter.name}");
                                localCallParameters.Add($"{parameter.name}");
                                remoteCallParameters.Add($"{parameter.name}");
                            }

                            generatedLines.Add($"public void _SendRPC{rpc.methodName}({string.Join(", ", methodParameters)}) {{");
                            if (mode == GenerationMode.Build)
                            {
                                generatedLines.Add($"    _rpc_manager._Send{modeName}({string.Join(", ", remoteCallParameters)});");
                                if (rpc.mode == RPCSyncMode.Variable) generatedLines.Add($"    if(target==null||target=={typeof(Networking).FullName}.LocalPlayer){rpc.methodName}({string.Join(", ", localCallParameters)});"); // Ensure local calls are not forgotten for variables
                            }

                            generatedLines.Add($"}}");
                        }

                        break;
                    default:
                        throw new Exception("Unrecognized generation mode: " + Enum.GetName(typeof(GenerationTarget), target));
                }
            }

            var newText = RegenerateFile(path, generatedLines);
            if (newText == null)
            {
                throw new Exception($"Could not regenerate RPCs in file: {path}!");
            }

            var oldText = File.ReadAllText(path);
            if (oldText == newText)
            {
                Debug.Log($"[DizzyRPC] Skipping regeneration of file: {path} - File has not changed.");
                return false;
            }

            Debug.Log($"[DizzyRPC] Regenerating contents of file: {path}");

            File.WriteAllText(path, newText);
            return true;
        }

        private static bool GenerateRPCs(RPCGraphData graph, UdonGraphProgramAsset program, GenerationMode mode)
        {
            return false;
        }

        private const string regionTag = "Generated RPCs (DO NOT EDIT)";

        private static string RegenerateFile(string path, List<String> generatedLines)
        {
            string[] lines = File.ReadAllLines(path);

            if (generatedLines.Count != 0)
            {
                generatedLines.Insert(0, $"#region {regionTag}");
                generatedLines.Add($"#endregion");
            }

            List<string> filePrefix = new();
            List<string> fileSuffix = new();

            bool foundRegionStart = false;
            bool foundRegionEnd = false;
            int indent = 0;
            // First, try to find #region tag
            for (int i = 0; i < lines.Length; i++)
            {
                if (foundRegionEnd) fileSuffix.Add(lines[i]);
                if (lines[i].Trim().Equals($"#region {regionTag}", StringComparison.InvariantCultureIgnoreCase))
                {
                    foundRegionStart = true;
                    indent = lines[i].IndexOf('#');
                }

                if (foundRegionStart && lines[i].Trim().Equals($"#endregion", StringComparison.InvariantCultureIgnoreCase))
                {
                    foundRegionEnd = true;
                }

                if (!foundRegionStart) filePrefix.Add(lines[i]);
            }

            if (foundRegionStart && foundRegionEnd)
            {
                string indentStr = "";
                for (int j = 0; j < indent; j++) indentStr += " ";
                return $"{string.Join("\n", filePrefix)}\n{indentStr}{string.Join($"\n{indentStr}", generatedLines)}\n{string.Join($"\n", fileSuffix)}";
            }

            // Region tag not found, insert at end of class.

            string fullFile = string.Join("\n", lines);

            string pattern = @".*?\[.*?GenerateRPCs.*?\].*?class.*?({).*";

            Regex regex = new Regex(pattern, RegexOptions.Singleline);
            var match = regex.Match(fullFile);

            if (!match.Success || match.Groups.Count <= 1)
            {
                throw new Exception($"Could not regenerate RPCs in file {path}! Class declaration was not found.");
            }

            int classStartIdx = match.Groups[1].Index;
            int braceCount = 0;
            int lastNewLineOrNonWhitespace = -1;
            bool lockIndent = false;
            indent = 0;
            // This doesn't handle using {} in strings and comments, but that's *fine* since this is the fallback system anyway. *Surely* there won't be mismatched braces in comments before it can ever generate the region, right?
            for (int i = classStartIdx; i < fullFile.Length; i++)
            {
                char c = fullFile[i];
                if (c == '{') braceCount++;
                if (c == '}') braceCount--;
                if (c == ' ' && !lockIndent) indent++;
                if (braceCount == 0)
                {
                    string indentStr = "";
                    for (int j = 0; j < indent; j++) indentStr += " ";
                    return $"{fullFile.Substring(0, lastNewLineOrNonWhitespace).Trim()}\n{indentStr}    {string.Join($"\n{indentStr}    ", generatedLines)}\n{indentStr}{fullFile.Substring(lastNewLineOrNonWhitespace).Trim()}";
                }

                if (!char.IsWhiteSpace(c) || c == '\n')
                {
                    lastNewLineOrNonWhitespace = i;
                    lockIndent = true;
                }

                if (c == '\n')
                {
                    lockIndent = false;
                    indent = 0;
                }
            }

            throw new Exception($"Could not regenerate RPCs in file {path}! End of class was not found.");
        }

        private enum GenerationTarget
        {
            Channel,
            MethodContainer
        }

        private enum GenerationMode
        {
            Clean,
            Editor,
            Build
        }

        public class GeneratedSingleton
        {
            public Type type;
            public int id;
            public string udonGraphGuid;
        }

        public class GeneratedRouter
        {
            public int id;
            public Type routerType;
            public string routerGraphName;
            public Type routableType;
            public string routableGraphName;
            public Type idType;
        }

        public class GeneratedRPC
        {
            public ushort id;
            public string methodName;
            public List<GeneratedRPCParameter> methodParameters;
            public GeneratedSingleton singleton;
            public GeneratedRouter router;
            public Type type;
            public bool isUniqueType;
            public string graphName;
            public RPCSyncMode mode;
            public bool ignoreDuplicates;
            public string TypeName => graphName ?? (isUniqueType ? type.Name : type.FullName).Replace('.', '_');
            public string FullTypeName => graphName ?? type.FullName;
            public List<GeneratedRPCHook> hooks = new();
        }

        public class GeneratedRPCParameter
        {
            public string name;
            public Type type;

            public GeneratedRPCParameter()
            {
            }

            public GeneratedRPCParameter(ParameterInfo info)
            {
                name = info.Name;
                type = info.ParameterType;
            }
        }

        public class GeneratedRPCHook
        {
            public GeneratedSingleton singleton;
            public string methodName;
            public List<GeneratedRPCParameter> methodParameters;
        }
    }
}